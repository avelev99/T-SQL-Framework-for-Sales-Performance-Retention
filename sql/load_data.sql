/*
    load_data.sql

    This script populates the eâ€‘commerce warehouse defined in
    create_tables.sql with data from CSV files.  It assumes that the CSV
    files were generated by the companion Python script (generate_data.py)
    and are available on the SQL Server host.  Adjust the file paths in
    the BULK INSERT statements to point to the correct locations on your
    server.  The script uses staging tables to mirror the structure of
    each CSV file before transforming and loading the data into the star
    schema.

    Note: Running this script requires the BULK INSERT privilege and
    appropriate access to the file system.  If you run this on a cloud
    service (e.g. Azure SQL), you may need to use OPENROWSET(BULK ...) or
    another import mechanism instead.
*/

USE ECommerceMiniDW;
GO

/*
    Drop staging tables if they exist.  Staging tables hold raw CSV
    content and mirror the column types of the source files.  They are
    truncated after loading into the final dimensions and facts.
*/
IF OBJECT_ID('stage_customers') IS NOT NULL DROP TABLE stage_customers;
IF OBJECT_ID('stage_sellers') IS NOT NULL DROP TABLE stage_sellers;
IF OBJECT_ID('stage_products') IS NOT NULL DROP TABLE stage_products;
IF OBJECT_ID('stage_translation') IS NOT NULL DROP TABLE stage_translation;
IF OBJECT_ID('stage_orders') IS NOT NULL DROP TABLE stage_orders;
IF OBJECT_ID('stage_order_items') IS NOT NULL DROP TABLE stage_order_items;
IF OBJECT_ID('stage_order_payments') IS NOT NULL DROP TABLE stage_order_payments;
IF OBJECT_ID('stage_order_reviews') IS NOT NULL DROP TABLE stage_order_reviews;
GO

/*
    Create staging tables matching the structure of each CSV file.  Data
    types are chosen to accommodate the values generated in the Python
    script.  Dates are loaded as VARCHAR and converted later to DATE to
    handle any format issues gracefully.
*/
CREATE TABLE stage_customers (
    customer_id              VARCHAR(32)    NOT NULL,
    customer_unique_id       VARCHAR(32)    NOT NULL,
    customer_zip_code_prefix VARCHAR(10)    NULL,
    customer_city            NVARCHAR(100)  NULL,
    customer_state           NVARCHAR(10)   NULL
);

CREATE TABLE stage_sellers (
    seller_id                VARCHAR(32)    NOT NULL,
    seller_zip_code_prefix   VARCHAR(10)    NULL,
    seller_city              NVARCHAR(100)  NULL,
    seller_state             NVARCHAR(10)   NULL
);

CREATE TABLE stage_products (
    product_id               VARCHAR(32)    NOT NULL,
    product_category_name    NVARCHAR(100)  NULL,
    product_name_length      INT            NULL,
    product_description_length INT           NULL,
    product_photos_qty       INT            NULL,
    product_weight_g         INT            NULL,
    product_length_cm        INT            NULL,
    product_height_cm        INT            NULL,
    product_width_cm         INT            NULL
);

CREATE TABLE stage_translation (
    product_category_name        NVARCHAR(100)  NOT NULL,
    product_category_name_english NVARCHAR(100) NOT NULL
);

CREATE TABLE stage_orders (
    order_id                    VARCHAR(32)    NOT NULL,
    customer_id                 VARCHAR(32)    NOT NULL,
    order_status                NVARCHAR(20)   NOT NULL,
    order_purchase_timestamp    VARCHAR(50)    NOT NULL,
    order_approved_at           VARCHAR(50)    NOT NULL,
    order_delivered_carrier_date VARCHAR(50)   NULL,
    order_delivered_customer_date VARCHAR(50)   NULL,
    order_estimated_delivery_date VARCHAR(50)   NOT NULL
);

CREATE TABLE stage_order_items (
    order_id                    VARCHAR(32)    NOT NULL,
    order_item_id               INT            NOT NULL,
    product_id                  VARCHAR(32)    NOT NULL,
    seller_id                   VARCHAR(32)    NOT NULL,
    shipping_limit_date         VARCHAR(50)    NOT NULL,
    price                       DECIMAL(18,2)  NOT NULL,
    freight_value               DECIMAL(18,2)  NOT NULL
);

CREATE TABLE stage_order_payments (
    order_id                    VARCHAR(32)    NOT NULL,
    payment_sequential          INT            NOT NULL,
    payment_type                NVARCHAR(50)   NOT NULL,
    payment_installments        INT            NOT NULL,
    payment_value               DECIMAL(18,2)  NOT NULL
);

CREATE TABLE stage_order_reviews (
    review_id                   VARCHAR(32)    NOT NULL,
    order_id                    VARCHAR(32)    NOT NULL,
    review_score                INT            NOT NULL,
    review_comment_title        NVARCHAR(200)  NULL,
    review_comment_message      NVARCHAR(MAX)  NULL,
    review_creation_date        VARCHAR(50)    NOT NULL,
    review_answer_timestamp     VARCHAR(50)    NOT NULL
);
GO

/*
    BULK INSERT operations.  Replace the file paths below with the
    absolute paths on your SQL Server machine.  The format options assume
    comma separated values with a header row.
*/
-- Example: set @rootPath to the directory containing your CSV files
-- DECLARE @rootPath NVARCHAR(4000) = 'C:\\path\\to\\tsql_ecommerce_project\\data';

-- BULK INSERT stage_customers
-- FROM CONCAT(@rootPath, '\\customers.csv')
-- WITH (FIELDTERMINATOR = ',', ROWTERMINATOR = '\n', FIRSTROW = 2, CODEPAGE = '65001', TABLOCK);

-- BULK INSERT stage_sellers
-- FROM CONCAT(@rootPath, '\\sellers.csv')
-- WITH (FIELDTERMINATOR = ',', ROWTERMINATOR = '\n', FIRSTROW = 2, CODEPAGE = '65001', TABLOCK);

-- ... Repeat BULK INSERT for each staging table

/*
    Populate dimension tables from staging tables.  The DISTINCT
    guarantees that duplicate rows in the CSV are collapsed into a single
    dimension record.  The OUTPUT clause could be added here to track
    surrogate keys if needed.
*/
INSERT INTO dim_customer (customer_id, customer_unique_id, zip_code_prefix, city, state)
SELECT DISTINCT customer_id, customer_unique_id, customer_zip_code_prefix, customer_city, customer_state
FROM stage_customers;

INSERT INTO dim_seller (seller_id, zip_code_prefix, city, state)
SELECT DISTINCT seller_id, seller_zip_code_prefix, seller_city, seller_state
FROM stage_sellers;

-- Insert category translations first and capture the generated keys
INSERT INTO dim_category (category_name, category_name_en)
SELECT DISTINCT product_category_name, product_category_name_english
FROM stage_translation;

-- Insert payment types
INSERT INTO dim_payment_type (payment_type)
SELECT DISTINCT payment_type
FROM stage_order_payments;

-- Insert review scores
INSERT INTO dim_review_score (review_score)
SELECT DISTINCT review_score
FROM stage_order_reviews;

/*
    Build the date dimension from all dates appearing in the orders,
    order items, reviews and payments.  Convert the VARCHAR dates into
    DATE types before extracting components.  Using a common CTE ensures
    that each date is inserted only once.
*/
WITH all_dates AS (
    SELECT CAST(order_purchase_timestamp AS DATE) AS dt FROM stage_orders
    UNION
    SELECT CAST(order_approved_at AS DATE) FROM stage_orders
    UNION
    SELECT CAST(order_delivered_carrier_date AS DATE) FROM stage_orders WHERE order_delivered_carrier_date IS NOT NULL
    UNION
    SELECT CAST(order_delivered_customer_date AS DATE) FROM stage_orders WHERE order_delivered_customer_date IS NOT NULL
    UNION
    SELECT CAST(order_estimated_delivery_date AS DATE) FROM stage_orders
    UNION
    SELECT CAST(shipping_limit_date AS DATE) FROM stage_order_items
    UNION
    SELECT CAST(review_creation_date AS DATE) FROM stage_order_reviews
    UNION
    SELECT CAST(review_answer_timestamp AS DATE) FROM stage_order_reviews
)
INSERT INTO dim_date (date_key, full_date, year, quarter, month, day_of_month, day_of_week)
SELECT
    CONVERT(INT, CONVERT(CHAR(8), dt, 112)) AS date_key,
    dt AS full_date,
    DATEPART(YEAR, dt) AS year,
    DATEPART(QUARTER, dt) AS quarter,
    DATEPART(MONTH, dt) AS month,
    DATEPART(DAY, dt) AS day_of_month,
    DATEPART(WEEKDAY, dt) AS day_of_week
FROM (
    SELECT DISTINCT dt FROM all_dates
) d
ORDER BY dt;

/*
    Load dim_product after dim_category is populated.  Map each product to
    the corresponding category_key via a subquery.
*/
INSERT INTO dim_product (
    product_id, category_key, name_length, description_length,
    photos_qty, weight_g, length_cm, height_cm, width_cm
)
SELECT
    p.product_id,
    c.category_key,
    p.product_name_length,
    p.product_description_length,
    p.product_photos_qty,
    p.product_weight_g,
    p.product_length_cm,
    p.product_height_cm,
    p.product_width_cm
FROM stage_products AS p
JOIN dim_category AS c ON c.category_name = p.product_category_name;

/*
    Load fact_orders.  Convert each timestamp into a date_key by joining
    against the dim_date table.  Orders reference the dim_customer via
    customer_key.  Optional dates (delivered dates) are handled via
    LEFT JOIN to dim_date.
*/
INSERT INTO fact_orders (
    order_id,
    customer_key,
    order_status,
    order_date_key,
    approved_date_key,
    delivered_carrier_date_key,
    delivered_customer_date_key,
    estimated_delivery_date_key
)
SELECT
    o.order_id,
    dc.customer_key,
    o.order_status,
    d_purchase.date_key,
    d_approved.date_key,
    d_carrier.date_key,
    d_customer.date_key,
    d_est.date_key
FROM stage_orders o
JOIN dim_customer dc ON dc.customer_id = o.customer_id
JOIN dim_date d_purchase ON d_purchase.full_date = CAST(o.order_purchase_timestamp AS DATE)
JOIN dim_date d_approved ON d_approved.full_date = CAST(o.order_approved_at AS DATE)
LEFT JOIN dim_date d_carrier ON d_carrier.full_date = CAST(o.order_delivered_carrier_date AS DATE)
LEFT JOIN dim_date d_customer ON d_customer.full_date = CAST(o.order_delivered_customer_date AS DATE)
JOIN dim_date d_est ON d_est.full_date = CAST(o.order_estimated_delivery_date AS DATE);

/*
    Load fact_order_items.  Resolve product_key and seller_key via the
    respective dimensions and translate the shipping date into a date_key.
*/
INSERT INTO fact_order_items (
    order_id,
    order_item_id,
    product_key,
    seller_key,
    shipping_date_key,
    price,
    freight_value
)
SELECT
    oi.order_id,
    oi.order_item_id,
    dp.product_key,
    ds.seller_key,
    d.date_key,
    oi.price,
    oi.freight_value
FROM stage_order_items oi
JOIN dim_product dp ON dp.product_id = oi.product_id
JOIN dim_seller ds ON ds.seller_id = oi.seller_id
JOIN dim_date d ON d.full_date = CAST(oi.shipping_limit_date AS DATE);

/*
    Load fact_payments.  payment_type_key is looked up in the
    dim_payment_type table.  Payment dates are not stored in this fact;
    instead, the order_date_key from fact_orders should be used for time
    based analysis by joining fact_payments to fact_orders.
*/
INSERT INTO fact_payments (
    order_id,
    payment_seq,
    payment_type_key,
    payment_installments,
    payment_value
)
SELECT
    p.order_id,
    p.payment_sequential,
    pt.payment_type_key,
    p.payment_installments,
    p.payment_value
FROM stage_order_payments p
JOIN dim_payment_type pt ON pt.payment_type = p.payment_type;

/*
    Load fact_reviews.  Look up the review_score_key and map the
    review dates through dim_date.  Reviews always reference existing
    orders in fact_orders.
*/
INSERT INTO fact_reviews (
    review_id,
    order_id,
    review_score_key,
    creation_date_key,
    answer_date_key
)
SELECT
    r.review_id,
    r.order_id,
    rs.review_score_key,
    d_creation.date_key,
    d_answer.date_key
FROM stage_order_reviews r
JOIN dim_review_score rs ON rs.review_score = r.review_score
JOIN dim_date d_creation ON d_creation.full_date = CAST(r.review_creation_date AS DATE)
JOIN dim_date d_answer ON d_answer.full_date = CAST(r.review_answer_timestamp AS DATE);

/*
    Clean up: optionally truncate staging tables to reclaim space.
*/
-- TRUNCATE TABLE stage_customers;
-- TRUNCATE TABLE stage_sellers;
-- TRUNCATE TABLE stage_products;
-- TRUNCATE TABLE stage_translation;
-- TRUNCATE TABLE stage_orders;
-- TRUNCATE TABLE stage_order_items;
-- TRUNCATE TABLE stage_order_payments;
-- TRUNCATE TABLE stage_order_reviews;

-- End of load_data.sql